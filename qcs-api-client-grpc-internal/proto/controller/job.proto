syntax = "proto3";
package models.controller;
option go_package = "gitlab.com/rigetti/share/service-model/golang/controller";
import "controller/job_metadata.proto";
import "controller/readout.proto";
import "controller/state.proto";
import "google/protobuf/timestamp.proto";

// Internal-only representation of the current phase in a job's lifecycle; this
// is a superset of the public `GetControllerJobStatusResponse.Status` field.
// Each phase is mapped to a public status by the `JobPhaseToJobStatus` function
// in the `controller` service repo.
// The mapping is as follows:
// SUBMITTED, NEW_ENQUEUED, PREEMPTED, and RETRYING:
//   -> QUEUED
// LOADING, TRIGGERING, and RUNNING:
//   -> RUNNING
// POST_PROCESSING:
//   -> POST_PROCESSING
// SUCCEEDED:
//   -> SUCCEEDED
// FAILED, RETRY_COUNT_EXCEEDED:
//   -> FAILED
// CANCELED:
//   -> CANCELED
// (Note that since clients are not able to query the status of a job before it
// has been queued, the mapping of `SUBMITTED` to `QUEUED` should not actually
// have any effect.)
enum JobPhase {
    UNKNOWN = 0;

    // SUBMITTED is the initial state of a job, prior to being enqueued.
    SUBMITTED = 1;

    // NEW_ENQUEUED indicates that the job has never been executed.
    NEW_ENQUEUED = 2;

    // LOADING is the hardware initialization stage.
    LOADING = 3;

    // TRIGGERING is the start of the actual execution.
    TRIGGERING = 4;

    // RUNNING is entered as soon as the job has been successfully triggered.
    RUNNING = 5;

    // FAILED indicates a failure that cannot be retried.
    FAILED = 6;

    // SUCCEEDED is the terminal state of a successful job.
    SUCCEEDED = 7;

    // PREEMPTED is a re-queued state; the job has been interrupted.
    PREEMPTED = 8;

    // CANCELED indicates that the job was canceled by the user.
    CANCELED = 9;

    // RETRYING is a re-queued state; the job had a transient failure.
    RETRYING = 10;

    // RETRY_COUNT_EXCEEDED indicates that the job had a retryable failure but has exceeded its retry count.
    RETRY_COUNT_EXCEEDED = 11;

    // POST_PROCESSING indicates that the job has finished executing on the quantum hardware, but is
    // not ready to be returned to the user. In some cases the postprocessing step is trivial, but
    // it may also include more complex operations that take a significant amount of time.
    POST_PROCESSING = 12;
}

// A ControllerJob is the result of compiling and packaging a higher-level program
// to run on a quantum processor. It may be parametric, allowing it to be modified
// just prior to execution using externally-supplied parameter values and other configuration.
message ControllerJob {

    // The settings to apply to and maintain on the controller throughout execution.
    // During execution, null-valued settings may have any value and change over time.
    // A missing key is equivalent to null values for all settings below that key.
    // There is no way to require that settings specified by other jobs are held constant during execution.
    .models.controller.ControllerSettings settings = 1;

    // The processing pipeline to transform raw results prior to return to the
    // user
    .models.controller.ReadoutPipeline pipeline = 2;

    // Programs to be loaded and run, keyed on instrument name
    // (as in `models.controller.ControllerServiceStartupConfiguration` and
    // `state`)
    map<string, .models.controller.InstrumentProgram> programs = 3;

    // Metadata describing the job data itself or the inputs used to build it
    .models.controller.JobMetadata metadata = 5;
}

// SignedControllerJob includes the configuration necessary to execute an instance of
// the contained job on control hardware alongside a signature attesting to the
// authenticity of the contained job.
message SignedControllerJob {

    // The job to be executed
    .models.controller.ControllerJob job = 1;

    // Signature used to assert integrity (i.e. that it was translated by a
    // Rigetti-trusted entity). This signature is computed on the
    // protobuf-serialized bytes of the contained `data`.
    .models.controller.JobSignature signature = 2;

    reserved 3;
    reserved "memory_values";}

// An EncryptedControllerJob includes the configuration necessary to execute an instance of
// the contained job data on control hardware in encrypted format.
message EncryptedControllerJob {

    // Encrypted form of ControllerJob.
    bytes job = 1;

    // Information about the means by which `inner` was encrypted.
    .models.controller.JobEncryption encryption = 2;

    reserved 3;
    reserved "memory_values";}

// Information about the means by which a ControllerJob was encrypted.
message JobEncryption {

    // Opaque identifier for the key to use in decryption
    string key_id = 1;

    // If relevant, the nonce to use in decryption
    bytes nonce = 2;
}
message JobExecutionConfiguration {

    // Memory values to be patched into the program by the Controller Service prior to execution.
    // The string key is used to match the name of the memory region as defined in the
    // InstrumentProgram. The type of the DataValue must match the defined type of the region.
    map<string, .models.controller.DataValue> memory_values = 3;

    // Additional information about this job execution that is not directly used
    // by the execution framework, but is useful for other analysis or debugging.
    .models.controller.JobExecutionMetadata job_execution_metadata = 4;
}

// Additional information about this job execution that is not directly used
// by the execution framework, but is useful for other analysis or debugging.
message JobExecutionMetadata {

    // Job Execution Metadata specific to execution through the Azure plaform.
    // See https://gitlab.com/rigetti/qcs/services/azure-integration/-/blob/main/docs/observability.md
    message AzureProvider {

        // The Job ID generated by Microsoft and provided to our integration.
        string provider_job_id = 1;
    }

    // Metadata provided only when a job is executed via 3rd party provider integration.
    oneof provider_metadata {

        // Metadata from the Azure integration.
        .models.controller.JobExecutionMetadata.AzureProvider azure = 101;
    }
}

// The JobSignature is used to assert integrity of a ControllerJob
// (i.e. that it was translated by a Rigetti-trusted entity).
message JobSignature {

    // Identifier for the key used to compute the signature;
    // implementation-specific
    string key_id = 1;

    // The signature itself
    bytes value = 2;
}

// This data is used to patch values into a pre-compiled binary prior to
// execution, and to retrieve data from memory following execution.
message MemoryRegion {

    // The type of data expected for patch values
    .models.controller.MemoryRegion.DataType data_type = 1;

    // The number of bytes to be read and written from the memory region at runtime.
    // The ratio of `length_bytes` to `length_count` varies by datatype and alignment.
    uint32 length_bytes = 2;

    // The word (8-byte) offset of the value within sequencer shared memory. This is used
    // for both patching of memory prior to execution and retrieval of the memory
    // following execution.
    //
    // An empty value indicates that the memory region is not patched into sequencer
    // shared memory.
    optional uint32 memory_offset_words = 3;

    // How to pack the user-provided value to binary format
    .models.controller.MemoryFormat format = 4;

    // Whether a patch value is optional for this memory region.
    // If true, the memory region is write-only and a default value will be patched in
    // if one is not provided by the user.
    bool patch_value_is_optional = 5;

    // The count of elements within the region.
    //
    // This is not inherently words or bytes! It depends on the memory format of the target
    // type. As of March 2024, all data types are packed to one item / word (even the binary datatype),
    // and thus length is the same as the number of memory words, but that stands to change in the future.
    uint32 length_count = 6;

    // The different types of data available for patching
    enum DataType {
        UNKNOWN_DATATYPE = 0;

        // Raw binary data; length is in bytes
        BINARY = 1;

        // 64-bit signed integer
        INTEGER = 2;

        // 64-bit signed floating-point number
        REAL = 3;
    }
}

// A description of a single memory value to be patched into a sequencer program
// based on a computation rather than a value provided directly by the user.
//
// It is used as follows:
//
// 1. The `computation` is evaluated within the scope of all values provided by the user,
//   which produces a new value
// 2. That value is packed into the format specified by `format`
// 3. The resulting value is patched into the memory region at `memory_offset_bytes`
message MemorySubstitution {

    // Where to insert the value, in bytes from the start of the sequencer's shared memory segment.
    // If unset, this value is not patched into shared memory.
    optional uint32 memory_offset_bytes = 1;

    // How to pack the value to binary format after computation
    .models.controller.MemoryFormat format = 2;

    // Where to insert the computed value in executable memory
    repeated .models.controller.ExecutableMemoryPatchTarget executable_memory_patch_targets = 3;

    // How to compute the value from the user-provided parameters
    oneof computation {
        string quil_expression = 101;
    }
}
message MemoryFormat {

    // Represent a number in fixed-point format: https://en.wikipedia.org/wiki/Fixed-point_arithmetic
    message FixedPoint {

        // How many bits to which to truncate the value
        uint32 mask_bits = 1;

        // How many places or bits to shift the input value to the left (if big-endian)
        uint32 scale_bits = 2;
    }

    // Format as a frequency value in Hz, per the format expected by the target sequencer.
    message Frequency {

        // If true, this frequency is an offset value from another frequency (a shift).
        // If false, this frequency is an absolute value.
        bool relative = 1;
    }
    oneof format {
        .models.controller.MemoryFormat.FixedPoint fixed_point = 201;
        .models.controller.MemoryFormat.Frequency frequency = 202;
    }
}

// Description for the site into which to patch a value into sequencer executable memory:
//
// * Start at the byte offset specified by `memory_offset_bytes` from the start of that sequencer's
//   executable memory segment
// * Mask the patch value to the `bit_width` least-significant bits
// * Overwrite the `bit_shift..bit_shift+bit_width` bits with the value
message ExecutableMemoryPatchTarget {

    // The byte offset of the value from the start of the sequencer's executable memory segment.
    uint32 memory_offset_bytes = 1;

    // How many bits to shift the value to the left before patching.
    uint32 bit_shift = 2;

    // The bit width of the value.
    uint32 bit_width = 3;
}

// The value of the data to insert into memory corresponding to a MemoryRegion.
message DataValue {
    oneof value {

        // Binary value, corresponding to both BIT and OCTET data types in Quil.
        .models.controller.BinaryDataValue binary = 101;

        // Signed integer value, corresponding to INTEGER in Quil.
        .models.controller.IntegerDataValue integer = 102;

        // Real number value, corresponding to REAL in Quil.
        .models.controller.RealDataValue real = 103;
    }
}

// Binary value, corresponding to both BIT and OCTET data types in Quil.
message BinaryDataValue {
    bytes data = 1;
}

// Signed integer value, corresponding to INTEGER in Quil.
message IntegerDataValue {
    repeated int64 data = 1;
}

// Real number value, corresponding to REAL in Quil.
message RealDataValue {
    repeated double data = 1;
}
message InstrumentProgram {
    oneof program {
        .models.controller.TsunamiInstrumentProgram tsunami = 101;
    }
}
message TsunamiInstrumentProgram {

    // Mapping by card slot to the program intended for the card.
    map<uint32, .models.controller.TsunamiCardProgram> card_programs = 1;
}
message TsunamiCardProgram {

    // Mapping of sequencer ID to the program intended for the sequencer.
    map<uint32, .models.controller.TsunamiSequencerProgram> sequencer_programs = 1;
}
message TsunamiSequencerProgram {

    // The instructions to be executed by the sequencer processor.
    bytes instructions = 1;

    // The MemoryMap maps user-specified memory region names to the specification
    // used to:
    //
    //   (a) patch them into the scheduled program binary prior to execution; and
    //   (b) read out their values following execution.
    //
    // These string keys are matched against the string keys in
    // ControllerJob.memory_values for memory patching prior to execution.
    map<string, .models.controller.MemoryRegion> memory_map = 2;

    // Substitutions for memory values which must be computed by the execution
    // service prior to patching into memory. They are applied in order, so
    // earlier substitutions will be clobbered by later ones.
    repeated .models.controller.MemorySubstitution memory_substitutions = 3;

    // Optional metadata describing the program for inspection and debugging
    .models.controller.QuercusSequencerProgramMetadata metadata = 4;
}

// A ControllerJobExecutionResult includes the result data from a single
// execution of a ControllerJob.
message ControllerJobExecutionResult {

    // The contents of each memory region, keyed on region name
    map<string, .models.controller.DataValue> memory_values = 1;

    // The contents of readout data published by the readout transformation
    // pipeline, keyed on the node ID of the publishing readout transformation
    // node.
    map<string, .models.controller.ReadoutValues> readout_values = 2;
    .models.controller.ControllerJobExecutionResult.Status status = 3;

    // Optional message providing context to the result's status.
    optional string status_message = 4;

    // Duration (µs) job held exclusive access to control hardware.
    uint64 execution_duration_microseconds = 5;

    // Internal data about the timing of specific phases in job execution (only included
    // if the user requesting the job result has appropriate permissions)
    repeated .models.controller.JobPhaseChange timing_data = 6;
    enum Status {
        UNKNOWN = 0;
        SUCCESS = 1;

        // Failure state caused by an error in the service.
        SERVICE_FAILURE = 2;

        // Failure state caused by user.
        USER_FAILURE = 3;

        // Job was canceled by user before execution completed.
        USER_CANCELLATION = 4;
    }
}

// Internal data with the time the job entered each phase during execution
message JobPhaseChange {

    // The instant when the job entered the new phase
    .google.protobuf.Timestamp timestamp = 1;
    .models.controller.JobPhase new_phase = 2;
}
