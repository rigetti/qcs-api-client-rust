syntax = "proto3";
package models.controller;
option go_package = "gitlab.com/rigetti/share/service-model/golang/controller";
import "google/protobuf/duration.proto";

// Metadata about a ControllerJob which cannot be derived from the job itself easily (or at all).
message JobMetadata {

    // How long (in wall-clock time) the job is expected to take in execution
    // after triggered. If unset, job execution time cannot be predetermined.
    .google.protobuf.Duration duration = 1;

    // The quantum processor ID for which this job was compiled
    //
    // Note: this field is not required (i.e. the string may be empty), and is
    // being deprecated in favor of `quantum_processor_ids` below. It will be
    // marked `optional` in a future release, which will be a breaking change for
    // some generated libraries (but not for the wire format).
    //
    // See the ConServ user guide for how this field is used:
    // https://gitlab.com/rigetti/qcs/services/controller/-/blob/master/docs/user-guide.md
    string quantum_processor_id = 2;

    // Metadata about the translation process that may be useful for metric reporting or results post-processing.
    .models.controller.TranslationMetadata translation_metadata = 3;

    // The quantum processor IDs for which this job was compiled
    //
    // Providing a single QPU ID in this list is equivalent to setting the
    // `quantum_processor_id` field. If both this field and `quantum_processor_id`
    // are set, `quantum_processor_id` will be ignored.
    //
    // This field is not required to run jobs. See the ConServ user guide for this field is used:
    // https://gitlab.com/rigetti/qcs/services/controller/-/blob/master/docs/user-guide.md
    repeated string quantum_processor_ids = 4;
}

// A `MemorySegment` describes a contiguous segment of memory within a blob,
// with a starting offset and length.
message MemorySegment {

    // Offset, in bytes, of this span within its parent
    uint32 offset_bytes = 1;

    // Length, in bytes, starting from the `offset`
    uint32 length_bytes = 2;
}

// Information about the translation process, especially custom features, that may be useful for reporting,
// job execution, or results post-processing. In contrast to `.models.translation.QuilTranslationMetadata`
// this information is intended for Controller service rather than the client.
message TranslationMetadata {

    // Set when the program has been pre-processed through Q-CTRL's API.
    .models.controller.TranslationMetadata.QCtrl q_ctrl = 1;

    // The raw program input as received from the client.
    .models.controller.TranslationMetadata.ProgramInput program_input = 2;

    // The version of the compiler used to translate the program to executable.
    .models.controller.TranslationMetadata.HardwareTranslator hardware_translator = 3;
    message ProgramInput {
        oneof value {
            string quil_text = 101;
            string quil_digest_sha256 = 102;
        }
    }
    message QCtrl {

        // The program identifier returned by Q-CTRL's pre-processing API.
        string program_identifier = 1;

        // The program input returned by Q-CTRL's pre-processing API.
        .models.controller.TranslationMetadata.ProgramInput program_input = 2;

        // Mapping of (Quil memory address as string) to (readout stream)
        // This allows a Quil program author to write and execute `MEASURE 0 ro`,
        // while being able to interpret the readout results for one of the post-processed
        // readout streams as representing the result of the `MEASURE`.
        //
        // Controller service will require this mapping to interpret readout results as
        // bitstrings, which are required for Q-CTRL's post-processing API.
        map<string, string> readout_mappings = 3;
    }
    message HardwareTranslator {

        // The package used to translate the program, e.g. "magneto"
        string name = 1;

        // The version of the package used to translate the program, e.g. "v1.0.0"
        string version = 2;
    }
}

// Description of a memory region used within the `SequencerProgram`
message QuercusSequencerProgramMemoryRegion {

    // Where the memory region is located within the shared memory segment.
    .models.controller.MemorySegment address = 1;

    // Human-readable descriptor to communicate the use of this segment. This
    // may be the Quil memory region's name, the system memory address label,
    // or something else.
    string descriptor = 2;
}

// Information about a QuercusSequencerProgram that is not used or needed for execution.
// This may be present for the benefit of service monitoring, disassemblers, or some other
// introspection.
//
// All of these fields should be considered optional and unstable by all users.
message QuercusSequencerProgramMetadata {

    // Data about the waveforms stored within the QuercusSequencerProgram.
    repeated .models.controller.QuercusSequencerProgramWaveformMetadata waveforms = 1;

    // String labels with their offsets (in instructions or 8-byte words) 
    // within the program's executable memory segment.
    //
    // The string may be defined by the user or the compiler; the offset
    // is 0-indexed from the first instruction within the program.
    //
    // Note that this structure reflects the fact that labels are unique but multiple
    // labels may describe the same offset within the program.
    map<string, uint32> labels = 2;

    // Information about the shared memory regions used within the program.
    // Note that this will overlap with the `memory_regions` patch table present
    // on the `SequencerProgram` itself, but this data is intended for human
    // consumption and debugging rather than memory patching. As such, it may describe
    // more regions than those which are directly patched (to include system memory regions
    // like shot count and error value).
    repeated .models.controller.QuercusSequencerProgramMemoryRegion shared_memory_regions = 4;

    // The channel index driven by this sequencer.
    optional uint32 channel_index = 5;
}

// Information about a waveform stored within a `QuercusSequencerProgram`
message QuercusSequencerProgramWaveformMetadata {

    // The location within the packed sequencer program waveform memory segment
    .models.controller.MemorySegment address = 1;

    // Whether the waveform is `flat` (same sample repeated for the duration)
    bool flat = 2;

    // Human-readable description of the waveform, possibly in Quil (e.g. "flat(iq: 1, duration: 1e-6)")
    // This is meant for human consumption only and should not be parsed by any other means,
    // as the format and content are subject to frequent change.
    string descriptor = 3;
}
